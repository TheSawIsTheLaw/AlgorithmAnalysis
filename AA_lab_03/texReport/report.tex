\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[justification=centering]{caption}

\lstdefinelanguage{Kotlin}{
  comment=[l]{//},
  commentstyle={\color{gray}\ttfamily},
  emph={delegate, filter, first, firstOrNull, forEach, lazy, map, mapNotNull, println, return@},
  emphstyle={\color{OrangeRed}},
  identifierstyle=\color{black},
  keywords={abstract, actual, as, as?, break, by, class, companion, continue, data, do, dynamic, else, enum, expect, false, final, for, fun, get, if, import, in, interface, internal, is, null, object, override, package, private, public, return, set, super, suspend, this, throw, true, try, typealias, val, var, vararg, when, where, while},
  keywordstyle={\color{blue}\bfseries},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[s]{"""*}{*"""},
  ndkeywords={@Deprecated, @JvmField, @JvmName, @JvmOverloads, @JvmStatic, @JvmSynthetic, Array, Byte, Double, Float, Int, Integer, Iterable, Long, Runnable, Short, String},
  ndkeywordstyle={\color{orange}\bfseries},
  sensitive=true,
  stringstyle={\color{green}\ttfamily},
}

% Для листинга кода:
\lstset{ %
language=Kotlin,                 % выбор языка для подсветки (здесь это С)
basicstyle=\footnotesize\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

\usepackage{hyperref}
\hypersetup{
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\begin{filecontents}{KA0.dat}
100 2148121
200 17350292
300 68920554
400 211301483
500 367822853
600 678478122
\end{filecontents}

\begin{filecontents}{KV0.dat}
100 2302331
200 22592034
300 73453362
400 205981760
500 351730341
600 658012453
\end{filecontents}

\begin{filecontents}{UKV0.dat}
100 1921005
200 1425033
300 57000923
400 172968826
500 340284336
600 625149992
\end{filecontents}

\begin{filecontents}{KA1.dat}
101 2312114
201 20247410
301 75166547
401 227614782
501 364368768
601 672846913
\end{filecontents}

\begin{filecontents}{KV1.dat}
101 2623891
201 21694235
301 77955778
401 218087162
501 362588416
601 671159157
\end{filecontents}

\begin{filecontents}{UKV1.dat}
101 2032155
201 17554153
301 64421195
401 171881527
501 358108198
601 647843183
\end{filecontents}


\begin{document}
\begin{titlepage}
	\fontsize{12pt}{12pt}\selectfont
	\noindent \begin{minipage}{0.15\textwidth}
		\includegraphics[width=\linewidth]{inc/img/b_logo.jpg}
	\end{minipage}
	\noindent\begin{minipage}{0.9\textwidth}\centering
		\textbf{Министерство науки и высшего образования Российской Федерации}\\
		\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
		\textbf{«Московский государственный технический университет имени Н.Э.~Баумана}\\
		\textbf{(национальный исследовательский университет)»}\\
		\textbf{(МГТУ им. Н.Э.~Баумана)}
	\end{minipage}
	
	\noindent\rule{15cm}{3pt}
	\newline\newline
	\noindent ФАКУЛЬТЕТ \underline{~~~~~~~~~~~~~~~~«Информатика и системы управления»~~~~~~~~~~~~~~~~} \newline\newline
	\noindent КАФЕДРА \underline{«Программное обеспечение ЭВМ и информационные технологии»}\newline\newline\newline\newline\newline\newline\newline
	
	
	\begin{center}
		\Large\textbf{Отчет по лабораторной работе №3 по курсу "Анализ алгоритмов"}\newline
	\end{center}
	
	\noindent\textbf{Тема} \underline{Алгоритмы сортировки}\newline\newline\newline
	\noindent\textbf{Студент} \underline{Якуба Д. В.}\newline\newline
	\noindent\textbf{Группа} \underline{ИУ7-53Б}\newline\newline
	\noindent\textbf{Оценка (баллы)} \underline{~~~~~~~~~~~~~~~~~~~}\newline\newline
	\noindent\textbf{Преподаватели} \underline{Волкова Л.Л., Строганов Ю.В.}\newline
	
	\begin{center}
		\vfill
		Москва~---~\the\year
		~г.
	\end{center}
\end{titlepage}

\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}
\section*{Цели лабораторной работы}
\begin{enumerate}
\item изучение алгоритмов сортировки пузырьком, вставками и выбором;
\item реализация алгоритмов сортировки пузырьком, вставками и выбором;
\item проведение сравнительного анализа трудоёмкости алгоритмов на основе теоретических расчетов и выбранной модели вычислений;
\item сравнительный анализ алгоритмов на основе экспериментальных данных;
\item подготовка отчёта по лабораторной работе;
\item получение практических навыков реализации алгоритмов на ЯП Kotlin.
\end{enumerate}
\section*{Определение}
Сортировка - это процесс перегруппироваки заданной последовательности объектов в некотором определённом порядке. Такой определённый порядок позволяет, в некоторых случаях, эффективнее работать с заданной последовательностью.

Пусть требуется упорядочить $N$ элементов: $E_1,E_2,...,E_n$. Каждый элемент представляет из себя запись $E_j$, содержащую некоторую информацию и ключ $K_j$, управляющий процессом сортировки. На множестве ключей определено отношение порядка $<$ так, чтобы для любых трёх значений ключей $a,b,c$ выполнялись следующие условия:

\begin{itemize}
\item Либо $a < b$, либо $b < c$, либо $a = b$;
\item Если $a < b$ и $b < c$, то $a < c$.
\end{itemize}

Данные условия определяют математическое понятие линейного и совершенного упорядочения, а удовлетворяющие им множества поддаются сортировке болшинством методов.

Задачей сортировки является нахождение такой перестановки записей $p(1)p(2)...p(n)$ с индексами ${1, 2, ..., N}$, после которой ключи расположились бы в порядке неубывания.

\begin{equation}
K_{p(1)} \leq K_{p(2)} \leq ... \leq K_{p(n)}
\end{equation}

\chapter{Аналитическая часть}

\section{Алгоритм сортировки пузырьком}
Алгоритм заключается в повторяющих проходах по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно. В том случае, если два элемента расположены не по порядку, то они меняются местами \cite{Knut}. Этот процесс повторяется до тех пор, пока элементы не будут упорядочены, то есть, в случае массива элементов размером $n$, проходы повторятся $n - 1$ раз.

\section{Алгоритм сортировки вставками}
Алгоритм заключается в следующей последовательности действий: элементы просматриваются по одному, и каждый новый элемент вставляется в подходящее место среди ранее упорядоченных элементов \cite{Knut}.

В начальный момент времени отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на нужную позицию в уже осотированной последовательности до тех пор, пока набор входных данных не будет исчерпан. В любой момент времени в отсортированной последовательности элеметы удовлетворяют требованиям к выходным данным алгоритма.

\section{Алгоритм сортировки выбором}
Алгорим заключается в следующей последовательности действий: сначала выделяется наименьший (наибольший) элемент последовательности и каким-либо образом отделяется от остальных, затем выбирается наименьший (наибольший) из оставшихся и т.д. \cite{Knut}

\section*{Вывод}
Были рассмотрены алгоритмы сортировки пузырьком, вставками и выбором. В данной работе стоит задача реализации рассмотренных алгоритмов. Также будет необходимо оценить теоретическую оценку алгоритмов и проверить её экспериментально.

\chapter{Конструкторская часть}
\section{Блок-схема алгоритма сортировки пузырьком}
Блок-схема алгоритма сортировки пузырьком предоставлена на рисунке \ref{img:bubbleSortScheme}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{inc/img/bubbleSort.png}
\captionsetup{justification=centering}
	\caption{Блок-схема алгоритма сортировки пузырьком.}
	\label{img:bubbleSortScheme}	
\end{center}
\end{figure}

\section{Блок-схема алгоритма сортировки вставками}
Блок-схема алгоритма сортировки вставками предоставлена на рисунке \ref{img:insertionSortScheme}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{inc/img/insertionSort.png}
\captionsetup{justification=centering}
	\caption{Блок-схема алгоритма сортировки вставками.}
	\label{img:insertionSortScheme}	
\end{center}
\end{figure}

\section{Блок-схема алгоритма сортировки выбором}
Блок-схема алгоритма сортировки выбором предоставлена на рисунке \ref{img:selectionSortScheme}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.33]{inc/img/selectionSort.png}
\captionsetup{justification=centering}
	\caption{Блок-схема алгоритма сортировки выбором.}
	\label{img:selectionSortScheme}	
\end{center}
\end{figure}

\newpage

\section{Модель вычислений}
ля последующего вычисления трудоемкости необходимо ввести модель вычислений:
\begin{enumerate}
    \item операции из списка (\ref{operators}) имеют трудоемкость 1;
        \begin{equation}
            \label{operators}
            +, -, /, \%, ==, !=, <, >, <=, >=, [], ++, {-}-, +=, -=, *=, \%=
        \end{equation}
    \item трудоемкость оператора выбора \textbf{условие then A else B} рассчитывается, как (\ref{if});
	\begin{equation}
        \label{if}
        f_{if} = f_{\text{условия}} +
        \begin{cases}
        f_A, & \text{если условие выполняется,}\\
        f_B, & \text{иначе.}
        \end{cases}
	\end{equation}
\item трудоемкость цикла рассчитывается, как (\ref{for});
    \begin{equation}
        \label{for}
        f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
    \end{equation}
	\item трудоемкость вызова функции равна 0.
\end{enumerate}

\section{Трудоёмкость алгоритмов}
\subsection{Соглашение}
Далее под некоторой величиной $size$ будет подразумеваться длина переданного массива.

\subsection{Алгоритм сортировки пузырьком}
Трудоёмкость алгоритма сортировки пузырьком будет включать включать в себя:
\begin{itemize}
\item цикл по $i \in [0..size - 1]$;
\item цикл по $j \in [0.. size - 1 - i]$, включённый в цикл по i.
\end{itemize}

При этом для цикла по $j$ из части блок-схемы, представленной на рисунке \ref{img:bubble:fj}, будем иметь:

\begin{equation}
f_{j} = 1 + 3 + \frac{1 + (size-1)}{2}(1 + 3 + f_{jbody})
\end{equation}
где $f_{jbody}$ - это трудоёмкость тела цикла, которая определяется выражением:

\begin{equation}
f_{jbody} = 5 + \begin{cases}
				0, & \textbf{лучший случай}\\
				9, & \textbf{худший случай}\\
				\end{cases}
\end{equation}

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{inc/img/bubblefj.png}
\captionsetup{justification=centering}
	\caption{Часть блок-схемы, определяющая $f_{j}$ и $f_{j body}$.}
	\label{img:bubble:fj}	
\end{center}
\end{figure}

Для цикла по $i$ из части блок-схемы, представленной на рисунке \ref{img:bubble:fi}, будем иметь:

\begin{equation}
f_{i} = 1 + 2 + (size - 1)f_{j}
\end{equation}

Как итог, имеем в лучшем случае:
\begin{equation}
f = f_{i} = 3 + (size-1)(4 + \frac{size}{2}(4 + 5)
\end{equation}

\begin{equation}
f = -1 + 4size + \frac{9}{2}{size}^2 - \frac{9}{2}size \approx \frac{9}{2}{size^2} = O({size}^2)
\end{equation}

В худшем случае:
\begin{equation}
f = f_{i} = 3 + (size-1)(4 + \frac{size}{2}(4 + 14)
\end{equation}

\begin{equation}
f = -1 + 4size + 9{size}^2 - 9size \approx 9{size^2} = O({size}^2)
\end{equation}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{inc/img/bubblefi.png}
\captionsetup{justification=centering}
	\caption{Часть блок-схемы, определяющая $f_{i}$.}
	\label{img:bubble:fi}	
\end{center}
\end{figure}
\newpage 

\subsection{Алгоритм сортировки вставками}
Трудоёмкость алгоритма сортировки вставками будет включать включать в себя:
\begin{itemize}
\item цикл по $i \in [1..size]$;
\item цикл по $j \in [i..0]$, включённый в цикл по i.
\end{itemize}

При этом для цикла по $j$ из части блок-схемы, представленной на рисунке \ref{img:insertion:fj}, будем иметь:

\begin{equation}
f_{j} = 3 + 4 + \frac{size}{2}\begin{cases}
				4, & \textbf{лучший случай}\\
				1 + 4 + f_{jbody}, & \textbf{худший случай}\\
				\end{cases}
\end{equation}
где $f_{jbody}$ - это трудоёмкость тела цикла, которая определяется выражением:

\begin{equation}
f_{jbody} = 4
\end{equation}

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{inc/img/insertionfj.png}
\captionsetup{justification=centering}
	\caption{Часть блок-схемы, определяющая $f_{j}$ и $f_{j body}$.}
	\label{img:insertion:fj}	
\end{center}
\end{figure}

Для цикла по $i$ из части блок-схемы, представленной на рисунке \ref{img:insertion:fi}, будем иметь:

\begin{equation}
f_{i} = 1 + 1 + (size - 1)(1 + 1 + f_{j})
\end{equation}

Как итог, имеем в лучшем случае:
\begin{equation}
f = f_{i} = 2 + (size - 1)(9 + 2size)
\end{equation}

\begin{equation}
f = 2{size}^2 + 7size - 7 \approx 2{size}^2 = O({size^2})
\end{equation}

В худшем случае:
\begin{equation}
f = f_{i} = 3 + (size-1)(4 + \frac{size}{2}(4 + 14)
\end{equation}

\begin{equation}
f = -1 + 4size + 9{size}^2 - 9size \approx 9{size^2} = O({size}^2)
\end{equation}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{inc/img/insertionfi.png}
\captionsetup{justification=centering}
	\caption{Часть блок-схемы, определяющая $f_{i}$.}
	\label{img:insertion:fi}	
\end{center}
\end{figure}
\newpage 

\subsection{Алгоритм сортировки выбором}
Трудоёмкость алгоритма сортировки выбором будет включать включать в себя:
\begin{itemize}
\item цикл по $i \in [0..size - 1]$;
\item цикл по $j \in [i + 1..size]$, включённый в цикл по i.
\end{itemize}

При этом для цикла по $j$ из части блок-схемы, представленной на рисунке \ref{img:selection:fj}, будем иметь:

\begin{equation}
f_{j} = 3 + 1 + \frac{size}{2}(1 + 1 + f_{jbody})
\end{equation}
где $f_{jbody}$ - это трудоёмкость тела цикла, которая определяется выражением:

\begin{equation}
f_{jbody} = \begin{cases}
				3, & \textbf{лучший случай}\\
				4, & \textbf{худший случай}\\
				\end{cases}
\end{equation}

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{inc/img/selectionfj.png}
\captionsetup{justification=centering}
	\caption{Часть блок-схемы, определяющая $f_{j}$ и $f_{j body}$.}
	\label{img:selection:fj}	
\end{center}
\end{figure}

Для цикла по $i$ из части блок-схемы, представленной на рисунке \ref{img:selection:fi}, будем иметь:

\begin{equation}
f_{i} = 1 + 1 + (size - 1)(1 + 1 + 2 + f_{j})
\end{equation}

Как итог, имеем в лучшем случае:
\begin{equation}
f = f_{i} = 2 + (size - 1)(4 + 4 + \frac{size}{2}(1 + 1 + 3))
\end{equation}

\begin{equation}
f = -6 + \frac{11}{2}size + \frac{5}{2}{size}^2 \approx \frac{5}{2}{size}^2 = O({size}^2)
\end{equation}

В худшем случае:
\begin{equation}
f = f_{i} = 2 + (size - 1)(4 + 4 + \frac{size}{2}(1 + 1 + 4))
\end{equation}

\begin{equation}
f = -6 + 5size + 3{size}^2 \approx 3{size}^2 = O({size}^2)
\end{equation}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{inc/img/selectionfi.png}
\captionsetup{justification=centering}
	\caption{Часть блок-схемы, определяющая $f_{i}$.}
	\label{img:selection:fi}	
\end{center}
\end{figure}
\newpage 

\section*{Вывод}
На основе теоретичесих данных, полученных из аналитического раздела, были построены схемы рассматриваемых алгоритмов сортировок, оценены их трудоёмкости в лучшем и худшем случаях.

\chapter{Технологическая часть}
\section{Требования к программному обеспечению}
Программное обеспечение принимает на вход массив целочисленных значений.

В результате выполнения программы должен быть получен упорядоченный по возрастанию массив.

\section{Средства реализации программного обеспечения}
При написании программного продукта был использован язык программирования Kotlin \cite{Kotlin}.

Данный выбор обусловлен следующими факторами:
\begin{itemize}
\item Возможность портирования алгоритмов для работы с Android;
\item Возможность часто употреблять выражение "Ко-ко-котлин" или "Котик";
\item Большое количество справочной литературы, связанной с ЯП Java.
\end{itemize}

Для тестирования производительности реализаций алгоритмов использовалась утилита measureTimedValue.

При написаннии программного продукта использовалась среда разработки IntelliJ IDEA.

Данный выбор обусловлен тем, что язык программирования Kotlin - это разработка компании JetBrains, поставляющей данную среду разработки.

\section{Листинг кода}
В листингах \ref{list:bubbleSort} - \ref{list:selectionSort} предоставлены реализации рассматриваемых алгоритмов.
\begin{lstlisting}[caption=Функция реализации алгоритма сортировки пузырьком,
label={list:bubbleSort}]
fun bubbleSort(arr: IntArray)
{
    var i = 0;
    while (i < arr.size - 1)
    {
        var j = 0;
        while (j < arr.size - 1 - i)
        {
            if (arr[j] > arr[j + 1])
                arr[j + 1] = arr[j].also { arr[j] = arr[j + 1] }
            j++
        }
        i++
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=Функция реализации алгоритма сортировки вставками,
label={list:insertionSort}]
fun insertionSort(arr: IntArray)
{
    var i = 1;
    while (i < arr.size)
    {
        var min = arr[i]
        var j = i;
        while (j > 0 && arr[j - 1] > min)
        {
            arr[j] = arr[j - 1]
            j--
        }
        arr[j] = min
        i++
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=Функция реализации алгоритма сортировки выбором,
label={list:selectionSort}]
fun selectionSort(arr: IntArray)
{
    var i = 0;
    while (i < arr.size - 1)
    {
        var j = i + 1
        var min = i
        while (j < arr.size)
        {
            if (arr[j] < arr[min])
                min = j
            j++
        }
        if (min != i)
            arr[i] = arr[min].also { arr[min] = arr[i] }
        i++
    }
}
\end{lstlisting}

\section{Тестирование программного продукта}
В таблице~\ref{tests} приведены тесты для функций, реализующих алгоритм сортировки пузырьком, вставками и выбором. Тесты пройдены успешно.

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			Начальный массив & Ожидаемый результат & Полученный результат \\ 
			\hline
			$[5, 4, 3, 2, 1]$ & $[1, 2, 3, 4, 5]$  & $[1, 2, 3, 4, 5]$\\
			$[0, 0, 0]$  & $[0, 0, 0]$  & $[0, 0, 0]$\\
			$[1, 2, 3]$ & $[1, 2, 3]$ & $[1, 2, 3]$\\
			$[-8, 2, 3, -2]$ & $[-8, -2, 2, 3]$ & $[-8, -2, 2, 3]$\\
			$[]$  & $[]$  & $[]$\\
			\hline
		\end{tabular}
		\caption{\label{tests}Тестирование функций}
	\end{center}
\end{table}
\section*{Вывод}
Спроектированные алгоритмы сортировок были реализованы и протестированы.

\chapter{Исследовательская часть}

\section{Пример работы программного обеспечения}
Ниже на рисунках \ref{img:exampleOut1}- \ref{img:exampleOut2} предоставлены примеры работы каждого из алгоритмов на введённых пользователем данных.

\begin{figure}
\begin{center}
\includegraphics[scale=1]{inc/img/exampleOutput.png}
\captionsetup{justification=centering}
	\caption{Пример работы ПО.}
	\label{img:exampleOut1}	
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=1]{inc/img/exampleOutput1.png}
\captionsetup{justification=centering}
	\caption{Пример работы ПО.}
	\label{img:exampleOut2}	
\end{center}
\end{figure}

\newpage

\section{Технические характеристики}
Технические характеристики ЭВМ, на котором выполнялись исследования:
\begin{itemize}
\item ОС: Manjaro Linux 20.1.1 Mikah
\item Оперативная память: 16 Гб
\item Процессор: Intel Core i7-10510U

При проведении замеров времени ноутбук был подключен к сети электропитания.
\end{itemize}

\section{Время выполнения алгоритмов}
Алгоритмы тестировались на данных, сгенерированных случайным образом один раз.

Результаты замеров времени приведены в таблицах \ref{time1} - \ref{time3}. На рисунках \ref{timeRes1} и \ref{timeRes3} приведены графики зависимостей времени работы алгоритмов от количества элементов в случаях передачи упорядочнного, неупорядоченного и упорядоченного в обратном порядке массива. В таблице СП - Сортировка Пузырьком, СВст - Сортировка Вставками, СВыб - Сортиовка выбором.

\newpage
\begin{table}[h]
	\begin{center}
		\caption{\label{time1} Замеры времени для упорядоченных массивов}
		\begin{tabular}{|c c c c|} 
 			\hline
			Размер массива & СП & СВст & СВыб \\ [0.5ex] 
 			\hline\hline
 			100 & 1818544 & 1630961 & 1826308\\
 			\hline
 			200 & 2182084 & 1647635 & 2144446 \\
 			\hline
			300 & 2836575 & 1640207 & 2530081\\
			\hline
			400 & 3666706 & 1640022 & 2924786\\
			\hline
			500 & 4561938 & 1645407 & 3594866\\
			\hline
			1000 & 12282615 & 1654109 & 8634889\\
			\hline
			1500 & 25296835 & 1662390 & 17374004\\
			\hline
			2000 & 43069012 & 1700609 & 29104145\\
			\hline
			3000 & 91881622 & 1810398 & 61997393\\
			\hline
			4000 & 165458964 & 1823571 & 105764286\\
			\hline
			5000 & 248940636 & 1766772 & 164210924\\
			\hline
			\end{tabular}
	\end{center}
\end{table}

\begin{table}[h]
	\begin{center}
		\caption{\label{time2} Замеры времени для неупорядоченных массивов}
		\begin{tabular}{|c c c c|} 
 			\hline
			Размер массива & СП & СВст & СВыб \\ [0.5ex] 
 			\hline\hline
 			100 & 1902381 & & \\
 			\hline
 			200 & 2690147 & & \\
 			\hline
			300 & 3973067 & & \\
			\hline
			400 & 6108805 & & \\
			\hline
			500 & 8344909 &  & \\
			\hline
			1000 & 28119897 &  & \\
			\hline
			1500 & 59508253 &  & \\
			\hline
			2000 & 102249552 &  & \\
			\hline
			3000 & 218854972 &  & \\
			\hline
			4000 & 379629421 &  & \\
			\hline
			5000 & 592686305 &  	& \\
			\hline
			\end{tabular}
	\end{center}
\end{table}

\begin{table}[h]
	\begin{center}
		\caption{\label{time3} Замеры времени для упорядоченных в обратном порядке массивов}
		\begin{tabular}{|c c c c|} 
 			\hline
			Размер массива & СП & СВст & СВыб \\ [0.5ex] 
 			\hline\hline
 			100 & & & \\
 			\hline
 			200 & & & \\
 			\hline
			300 & & & \\
			\hline
			400 & & & \\
			\hline
			500 & &  & \\
			\hline
			1000 &  &  & \\
			\hline
			1500 &  &  & \\
			\hline
			2000 &  &  & \\
			\hline
			3000 &  &  & \\
			\hline
			4000 &  &  & \\
			\hline
			5000 &  &  	& \\
			\hline
			\end{tabular}
	\end{center}
\end{table}

\begin{figure}[h]
\begin{center}
	\begin{tikzpicture}

\begin{axis}[
  		  	axis lines = left,
  		  	xlabel = размер,
  		  	ylabel = {время, нс},
			legend pos=north west,
			ymajorgrids=true
		] 
		\addplot[color=orange] table[x index=0, y index=1] {KA0.dat};
		\addplot[color=blue, mark=square] table[x index=0, y index=1] {KV0.dat};
		\addplot[color=green, mark=square] table[x index=0, y index=1] {UKV0.dat};

		\addlegendentry{КА}
		\addlegendentry{КВ}
		\addlegendentry{УКВ}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы от размера матриц (чётные значения размерностей)}
	\label{timeRes1}
	\end{center}
\end{figure}

\begin{figure}[h]
	\begin{center}
	\begin{tikzpicture}

		\begin{axis}[
 		   	axis lines = left,
 		   	xlabel = размер,
 		   	ylabel = {время, нс},
			legend pos=north west,
			ymajorgrids=true
		]
		\addplot[color=orange] table[x index=0, y index=1] {KA1.dat};
		\addplot[color=blue, mark=square] table[x index=0, y index=1] {KV1.dat};
		\addplot[color=green, mark=square] table[x index=0, y index=1] {UKV1.dat};

		\addlegendentry{КА}
		\addlegendentry{КВ}
		\addlegendentry{УКВ}
		\end{axis}
\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы от размера матриц (нечётные значения размерностей)}
	\label{timeRes2}
	\end{center}
\end{figure}

\section*{Вывод}
При сравнении результатов замеров времени заметно, что скорость работы классического алгоритма однозначно отстаёт от скорости работы улучшенного Алгоритма Копперсмита-Винограда. Уже на 600 элементах улучшенный алгоритм Копперсмита-Винограда работает быстрее классического на $\approx8\%$. При нечётном количестве строк и столбцов матриц улучшенный алгоритм способен быть медленнее $\approx4\%$, при факте того, что классический алгоритм похожей динамики не имеет. Обычный алгоритм Копперсмита-Винограда начинает выигрывать по скорости классический только по достижению 300 строк и столбцов в матрице, при факте того, что в случае матрицы с нечётной размерностью он всё ещё будет проигрывать. При размерности 600 он будет выгрывать у классической реализации на $\approx3\%$. В случае матриц размера меньше 400 на 400 его использование не будет целесообразным.

\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
В ходе выполнения лабораторной работы:
\begin{itemize}
\item были изучены алгоритмы умножения матриц: классический, Копперсмита-Винограда и улучшенный Копперсмита-Винограда;
\item были реализованы алгоритмы умножения матриц: классический, Копперсмита-Винограда и улучшенный Копперсмита-Винограда;
\item был произведён анализ трудоёмкости указанных алгоритмов на основе теоретических расчётов и выбранной модели вычислений;
\item был выполнен сравнительный анализ производительности алгоритмов на основе полученных экспериментальных данных;
\item был подготовлен отчёт по проделанной работе;
\item были получены практические навыки реализации алгоритмов на ЯП Kotlin.
\end{itemize}

Исследования показали, что использование алгоритма Копперсмита-Винограда способно оправдать себя только в случае матриц, размерность которых не менее 400. При этом выигрыш будет составлять $\approx0.2\%$ только в случае чётной размерности. Реализация улучшенного алгоритма Копперсмита-Винограда показывает результаты быстрее классического алгоритма уже при размерности матрицы 100. Чем больше элементов в матрице, тем заметнее разница во времени работы этих двух алгоритмов. При размерности матрицы 600 модифицированный алгоритм Копперсмита-Винограда показывает себя лучше классического алгоритма на $\approx8\%$.

\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{utf8gost705u}  % стилевой файл для оформления по ГОСТу
\bibliography{biblio.bib}          % имя библиографической базы (bib-файла)


\end{document} 
